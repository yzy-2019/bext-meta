{"type":"javascript","name":"Via 浏览器接口模拟 for X","version":"1","tags":["工具脚本"],"synopsis":"模拟 Via 浏览器接口，以便 X 浏览器安装和使用用于 Via 的脚本。","detail":"<p><strong>仅适用于 X 浏览器</strong></p><p><br></p><p>这个脚本模拟 Via 浏览器的接口，以便 X 浏览器可以安装并使用 Via 的脚本。</p><p><br></p><p>当前支持模拟的接口有 :</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">via.searchText\n</pre><p><em>使用浏览器设置的引擎搜索文字</em></p><p>如果 X 浏览器版本大于 3.7.3 ，使用 x://s?q= 地址。</p><p>否则，将调用 <em>搜索引擎</em> 中设置的引擎。</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">via.toast\n</pre><p><em>弹出 Toast</em></p><p>直接调用 mbrowser.showToast() 。</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">via.record\n</pre><p><em>添加广告拦截规则</em></p><p>转换为 ADB 规则，然后调用 mbrowser.addAdBlockRule() 。</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">via.getInstalledAddonID\n</pre><p><em>获取已安装脚本 ID</em></p><p>安装时会使用特定前缀 <strong>56696120811a672c################</strong></p><p>( # 为填充 0 的 Via 插件 ID ) 来标记 Via 脚本 。</p><p>其它脚本 ID 前缀不同，不会上报。</p><p>对于手动添加的脚本，X 浏览器的脚本 ID 是随机生成的。</p><p>只要前缀碰巧对上了，就会被认为是 Via 脚本，<strong>从而干扰上报功能</strong>。</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">via.addon\n</pre><p><em>安装或卸载脚本</em></p><p>将脚本内容转换编码，生成脚本头，然后安装。其中 :</p><p><br></p><ol><li>转换编码阶段 ：Via 的插件接口支持 UTF-8 编码转换，但 X 浏览器不支持。尽管这边实现了编码转换，然而判断方法<strong>并不可靠</strong>。所以，如果脚本里有特殊字符，<strong>仍然可能会导致乱码、无法使用的情况</strong>。</li><li>生成脚本头阶段 ：如果打开了<em>罗嗦模式</em>，生成脚本头的时候会询问你两个问题，<strong>修改执行方式</strong>相当于 X 浏览器的 “设置脚本执行方式”，改完以后点悬浮框继续安装。<strong>修改 @run-at 标记</strong>详见 <a href=\"https://www.xbext.com/docs/tutorials/write-user-script-for-xbrowser-part2/\" rel=\"noopener noreferrer\">官方文档</a> 对于 @run-at 的描述。如果 Via 脚本接口提供了域名，那么这时设置的域名<strong>会被覆盖</strong>。如果不设置 @run-at 标记，@run-at 将不会包含在脚本头中。</li><li>安装阶段 ：X 浏览器接口需要脚本描述，安装时会从脚本内容里提取。如果脚本里没有描述，将会使用当前网址作为描述内容。在安装成功后将跳到脚本列表界面，如果没有看到要安装的脚本，或者没有跳到脚本列表界面，那就是安装失败了。( 跳到脚本列表界面是 X 浏览器的默认行为，无法阻止 )。</li></ol><p><br></p><p>如果脚本已经安装，则会调用<strong> mbrowser.uninstallScript()</strong> 进行卸载。</p><p><br></p><p>注意事项：</p><p><br></p><ol><li><strong>由于各种原因，不保证安装的脚本一定可用</strong>。</li><li>目前不打算实现 via.cmd 和 via.openSettings 。它们对于脚本不是必要的。</li><li><strong>不支持</strong> X 浏览器的脚本 \"更新\" 功能，点击脚本 \"更新\" 按钮会<strong>导致 X 浏览器崩溃</strong>。</li><li>第三方网站大多会不正确的判断是否卸载成功 (点了卸载就变安装)，所以请以实际行为结果为准。自行判断是否已经安装。</li><li>Via 和 X 的夜间模式是不同的，<strong>所以依赖夜间模式的脚本不会生效</strong>。</li><li>此脚本不支持低于 WebView 47 的系统内核。</li><li>X 浏览器 不支持在错误页面执行脚本，错误重定向类脚本不会被执行。</li></ol><p><br></p>","extra":{"xMetaComment":"// @run-at document-start\n// @type bookmarklet"},"configSchema":{"type":"object","properties":{"verbose":{"type":"boolean","title":"罗嗦模式","description":"安装脚本时，询问运行时机。"},"engine":{"type":"string","title":"搜索引擎","description":"设置 searchText 的备用搜索引擎","format":"uri","pattern":"=$"}},"required":["verbose"]},"defaultConfig":{"verbose":false,"engine":"https://www.baidu.com/s?wd="},"source":"import config from '@bext/config';\nif (!window.via) {\n    via = {\n        id: \"56696120811a672c################\",\n        searchText: s => {\n            let eng = (mbrowser.getVersionCode() >= 611) ?\n                'x://s?q=' : config.engine;\n            location.href = eng + s;\n        },\n        toast: s => { mbrowser.showToast(s) },\n        record: (h, r) => { mbrowser.addAdBlockRule(h + '##' + r, null, null, 0) },\n        toXID: function (id) {\n            while (id.length !== 16) id = '0' + id;\n            return this.id.replace('################', id);\n        },\n        convString: function (str) {\n            let u = false, u2s = str => {\n                var ab = new Uint8Array(str.length),\n                    td = new TextDecoder();\n                for (let i = 0; i < str.length; ++i) {\n                    ab[i] = str.charCodeAt(i);\n                }\n                return td.decode(ab);\n            };\n            for (let i = 0; i < str.length; ++i) {\n                if (str.charCodeAt(i) >= 228 && str.charCodeAt(i) <= 233) u = true;\n            }\n            return (u) ? u2s(str) : str;\n        },\n        getInstalledAddonID: function () {\n            let list = [];\n            JSON.parse(window.mbrowser.getUserScriptListByJson()).forEach(j => {\n                if (j.script_id.slice(0, 16) === this.id.slice(0, 16)) {\n                    list.push(parseInt(j.script_id.slice(16)));\n                }\n            });\n            return JSON.stringify(list);\n        },\n        contInstall: function (header, vao, a) {\n            if (config.verbose) {\n                if (confirm('你想要修改 @run-at 标记么?')) header += `// @run-at ${prompt('\\n\\\ndocument-start 指定脚本在DOM树开始的时候执行，需要脚本尽早执行的时候添加此声明。\\n\\\ndocument-end 指定脚本在DOM数据加载完毕的时候执行。\\n\\\ndocument-idle 页面加载完毕的时候执行。\\n\\\nmain-menu X浏览器的扩展声明，表示此脚本不自动执行，用户通过主菜单扩展点手动执行。\\n\\\ncontext-menu X浏览器扩展声明,表示此脚本不自动执行，用户通过长按菜单的扩展点执行。\\n\\\ntool-menu X浏览器扩展声明，表示此脚本不自动执行，用户通过页面工具菜单的扩展点执行。\\\n', 'document-idle')}\\n`;\n            }\n            header += `// @grant none\\n// ==/UserScript==\\n`;\n            mbrowser.addNewScript(JSON.stringify({\n                resource_id: this.toXID(parseInt(vao.id)),\n                title: this.convString(vao.name),\n                description: a.match(/ @description: (.*)/) ?\n                    a.match(/ @description: (.*)/)[1] : location.href,\n                nick_name: this.convString(vao.author),\n                content: header + a\n            }));\n        },\n        clickResolve: function (oce, header, vao, a) {\n            document.onclick = oce;\n            this.contInstall(header, vao, a);\n        },\n        addon: function (c) {\n            let vao = JSON.parse(atob(c)), list = JSON.parse(this.getInstalledAddonID()), \n            a = this.convString(atob(vao.code)), b, oce, asd = !1;\n\n            let header = `// ==UserScript==\\n`;\n            if (a.match(/ @name: (.*)/)) {\n                header += `// @name ${a.match(/ @name: (.*)/)[1]}\\n`;\n            }\n            if (a.match(/ @version: (.*)/)) {\n                header += `// @version ${a.match(/ @version: (.*)/)[1]}\\n`;\n            }\n            if (a.match(/ @description: (.*)/)) {\n                header += `// @description ${a.match(/ @description: (.*)/)[1]}\\n`;\n            }\n            if (a.match(/ @include: (.*)/)) {\n                asd = a.match(/ @include: (.*)/)[1]; b = asd.split(',');\n                b.forEach(bd => { header += `// @match *://${bd}/*\\n`; });\n            }\n            header += `// @namespace ${location.href}\\n`;\n\n            if (list.includes(parseInt(vao.id))) {\n                mbrowser.uninstallScript(this.toXID(parseInt(vao.id)));\n            } else {\n                if (config.verbose) {\n                    if (confirm((asd) ? `你想要修改脚本执行方式么?\n插件已设置域名：${asd}\n如果要改域名请在安装后在 “编辑脚本” 里修改。` : '你想要修改脚本执行方式么?')) {\n                        mbrowser.showFloatMessageBox(true, '点击这里继续');\n                        mbrowser.chooseExpoint();\n                        oce = document.onclick;\n                        document.onclick = via.clickResolve.bind(via, oce, header, vao, a);\n                    } else {\n                        this.contInstall(header, vao, a);\n                    }\n                } else {\n                    this.contInstall(header, vao, a);\n                }\n            }\n        }\n    }\n}"}